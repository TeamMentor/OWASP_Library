<?xml version="1.0" encoding="utf-8"?>
<guidanceItem id="75bd5893-aa69-4d39-8cc8-004cee54aaae" Author="" Category="Input and Data Validation" Priority="1" Rule_Type="Guideline" Status="" Technology="Java" title="Validate Input for Length, Range, Format, and Type" Topic="Security" phase="Implementation" xmlns="urn:microsoft:guidanceexplorer:guidanceItem">
  <content>&lt;h1&gt;Applies to&lt;/h1&gt;&lt;ul&gt;&lt;li&gt;Applications written using Servlets or JSP.&lt;/li&gt;&lt;/ul&gt;&lt;h1&gt;What to Do&lt;/h1&gt;&lt;p&gt;Treat all input as untrusted data. Validate untrusted data using whitelist techniques to check against known good input.&lt;/p&gt;&lt;h1&gt;Why&lt;/h1&gt;&lt;p&gt;Unchecked malicious input may lead to integer overflows, injection based attacks, denial of service or information disclosure. &lt;/p&gt;&lt;h1&gt;When&lt;/h1&gt;&lt;p&gt;Always validate input. Do not assume that input is good based on origin.&lt;/p&gt;&lt;h1&gt;How&lt;/h1&gt;&lt;p&gt;Input can vary in several ways: length, data type contents. It is recommended to verify that all of these meet your application's expectations regarding its input.&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;strong&gt;Validating length&lt;/strong&gt;: Validating an input's length suggests that your application should check a string's length or the number of bits in a numeric value. Checking the length can help prevent buffer overflows as well as integer overflows in numeric values. A simple way of validating the numeric value can be done through the use of &lt;strong&gt;BigInteger/BigDecimal&lt;/strong&gt;:&lt;/li&gt;&lt;/ol&gt;&lt;blockquote&gt;&lt;blockquote&gt;&lt;pre&gt;public boolean validateLength(String input)&lt;br&gt;{&lt;br&gt;      if(validateType(input))&lt;br&gt;      {&lt;br&gt;            BigInteger bi = new BigInteger(input);&lt;br&gt;             if(bi.compareTo(BigInteger.valueOf(0)) &amp;gt; -1&lt;br&gt;               &amp;amp;&amp;amp; bi.compareTo(BigInteger.valueOf(Integer.MAX_VALUE)) &amp;lt; 1)&lt;br&gt;            {&lt;br&gt;                  return true;&lt;br&gt;            }&lt;br&gt;            else&lt;br&gt;            {&lt;br&gt;                  return false;&lt;br&gt;            }&lt;br&gt;      }&lt;br&gt;      else&lt;br&gt;      {&lt;br&gt;             return false;&lt;br&gt;      }&lt;br&gt;}&lt;/pre&gt;&lt;/blockquote&gt;&lt;/blockquote&gt;&lt;ol&gt;&lt;li&gt;&lt;strong&gt;Validating type&lt;/strong&gt;: Validating the input's data type is important when your application expects a specific non-string parameter. Difference in data type can trigger unhandled exceptions that would throw your application into an unknown state. Example for validating that input is of integer value:&lt;/li&gt;&lt;/ol&gt;&lt;blockquote&gt;&lt;blockquote&gt;&lt;pre&gt;public boolean validateType(String input)&lt;br&gt;{&lt;br&gt;      String goodPattern =\\d+;&lt;br&gt;      Pattern p = Pattern.compile(goodPattern);&lt;br&gt;      Matcher m = p.matcher(input);&lt;br&gt;            if(!m.matches())&lt;br&gt;      {&lt;br&gt;&lt;br&gt;            return false;&lt;br&gt;      }&lt;br&gt;      else&lt;br&gt;      {&lt;br&gt;            return true;&lt;br&gt;      }&lt;br&gt;}&lt;/pre&gt;&lt;/blockquote&gt;&lt;/blockquote&gt;&lt;ol&gt;&lt;li&gt;&lt;strong&gt;Validating contents&lt;/strong&gt;: Validating the input's contents can be achieved using whitelist and blacklist techniques. The choice between the use of black and white listing is based upon the constraints that are imposed on the input. If the input follows a tight structure and format, then your application can use whitelisting alone to weed out malicious input. If there are unknowns about the input, then a combination of black and white listing must be used. In general, use blacklisting as a backup to whitelisting. Use a spiral-out approach as input is initially validated using whitelist techniques. When whitelisting cannot validate the input, fall back to blacklisting. If blacklist cannot validate, then discard the input.&lt;br&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote&gt;&lt;p&gt;Whitelist: Whitelisting involves the establishment of what is good input to your application. Once good input is defined, your application must compare all input against the established good input. If the input does not resemble good input, your application should discard it. This technique can be implemented using regular expressions. Example:&lt;/p&gt;&lt;blockquote&gt;&lt;pre&gt;&lt;br&gt;public boolean validateData(String input)&lt;br&gt;{&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; String goodPattern = "(\\w|\\d)+";&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; int goodLength = 10;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; if(input.length() &amp;gt; goodLength)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; return false;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; Pattern p = Pattern.compile(goodPattern);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; Matcher m = p.matcher(input);&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; if(!m.matches())&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; return false;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; else&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; return true;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;}&lt;/pre&gt;&lt;/blockquote&gt;&lt;p&gt;Examples of useful regular expressions: &lt;/p&gt;&lt;p&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;Use&lt;/td&gt;&lt;td&gt;Regular Expression&lt;/td&gt;&lt;td&gt;Java String&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Valid E-Mail Address&lt;/td&gt;&lt;td&gt;^\w+(\.|_|-){0,1}\w+@(\w+\.)*\w{3,1024}\.([a-zA-Z]{2}\.){0,1}[a-zA-Z]{2,4}$&lt;/td&gt;&lt;td&gt;^\\w+(\\.|_|-){0,1}\\w+@(\\w+\\.)*\\w{3,}\\.([a-zA-Z]{2}\\.){0,1}[a-zA-Z]{2,4}$&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Alpha-numeric free text&lt;/td&gt;&lt;td&gt;(\w|\d|\s|;|\?|!|,|\.|-|:)+&lt;/td&gt;&lt;td&gt;(\\w|\\d|\\s|;|\\?|!|,|\\.|-|:)+&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Word characters&lt;/td&gt;&lt;td&gt;\w+&lt;/td&gt;&lt;td&gt;\\w+&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Numbers&lt;/td&gt;&lt;td&gt;\d+&lt;/td&gt;&lt;td&gt;\\d+&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;ol&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Blacklist&lt;/strong&gt;: Blacklisting involves filtering the input for recognized malicious characters or strings. Using the blacklist approach, the goal is to discard all input that contains known bad data. Because this technique relies on searching the input for all blacklisted characters and/or strings, it can be quite expensive. Example:&lt;/li&gt;&lt;/ul&gt;&lt;/ol&gt;&lt;blockquote&gt;&lt;blockquote&gt;&lt;pre&gt;public boolean validateData(String input)&lt;br&gt;{&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; if(input.indexOf("&amp;lt;") &amp;gt; -1)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; return false;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; if(input.indexOf("&amp;gt;") &amp;gt; -1)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; return false;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; if(input.indexOf("\"") &amp;gt; -1)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; return false;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; if(input.indexOf("\'") &amp;gt; -1)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; return false;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; return true;&lt;br&gt;}&lt;/pre&gt;&lt;/blockquote&gt;&lt;/blockquote&gt;&lt;ol&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; This function only describes what blacklisting is. It does not exhaust the different possible inputs that can be blacklisted in an application. Be aware that blacklisting can also be implemented using regular expressions:&lt;/p&gt;&lt;blockquote&gt;&lt;pre&gt;public boolean validateData(String input)&lt;br&gt;{&lt;br&gt;      String badPattern = "(&amp;lt;|\"|\'|(.*))(&amp;lt;|\"|\'|&amp;gt;).*";&lt;br&gt;      int goodLength = 10;&lt;br&gt;      if(input.length() &amp;gt; goodLength)&lt;br&gt;      {&lt;br&gt;            return false;&lt;br&gt;      }&lt;br&gt;      Pattern p = Pattern.compile(badPattern);&lt;br&gt;      Matcher m = p.matcher(input);&lt;br&gt;            if(!m.matches())&lt;br&gt;      {&lt;br&gt;            return true;&lt;br&gt;      }&lt;br&gt;      else&lt;br&gt;      {&lt;br&gt;            return false;&lt;br&gt;      }&lt;br&gt;}&lt;/pre&gt;&lt;/blockquote&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h1&gt;Problem Example&lt;/h1&gt;&lt;p&gt;The following code produces a data analysis based on a financial index. Because the code does not validate its input, the application is vulnerable to SQL injection.&lt;/p&gt;&lt;blockquote&gt;&lt;pre&gt;import java.io.*;&lt;br&gt;import java.util.*;&lt;br&gt;import java.lang.*;&lt;br&gt;import javax.servlet.*;&lt;br&gt;import javax.servlet.http.*;&lt;br&gt;import java.util.regex.*;&lt;br&gt; public final class DataAggregator extends HttpServlet&lt;br&gt;{&lt;br&gt;      public void doGet(HttpServletRequest request, HttpServletResponse response)&lt;br&gt;            throws ServletException, IOException&lt;br&gt;      {&lt;br&gt;            PrintWriter out = response.getWriter();&lt;br&gt;            String searchTerm = request.getParameter("index");&lt;br&gt;             String retString;&lt;br&gt;             try&lt;br&gt;            {&lt;br&gt;                  // The application does not validate the user-supplied data&lt;br&gt;                  retString = "The queried index \"";&lt;br&gt;                  retString += encodeHtml(searchTerm); &lt;br&gt;                  retString += "\" produced the following results:&amp;lt;br&amp;gt; ";&lt;br&gt;                  out.println(retString);&lt;br&gt;                  common.aggregateData(out, searchTerm);&lt;br&gt;            }&lt;br&gt;             catch (Exception e)&lt;br&gt;            {&lt;br&gt;                  // Add the appropriate logging and exception handling&lt;br&gt;                  // mechanisms. Consult the Exception Handling and&lt;br&gt;                  // Logging sections&lt;br&gt;                  out.println("We cannot handle your request at the moment."&lt;br&gt;                            + "Please try again later.");&lt;br&gt;            }&lt;br&gt;             out.flush();&lt;br&gt;             out.close();&lt;br&gt;      }&lt;br&gt;  }&lt;/pre&gt;&lt;/blockquote&gt;&lt;h1&gt;Solution Example&lt;/h1&gt;&lt;p&gt;The following code produces a data analysis based on a financial index. Since the code validates the application's input, the application is secured from SQL injection.&lt;/p&gt;&lt;blockquote&gt;&lt;pre&gt;import java.io.*;&lt;br&gt;import java.util.*;&lt;br&gt;import java.lang.*;&lt;br&gt;import javax.servlet.*;&lt;br&gt;import javax.servlet.http.*;&lt;br&gt;import java.util.regex.*;&lt;br&gt; public final class DataAggregator extends HttpServlet&lt;br&gt;{&lt;br&gt;      public void doGet(HttpServletRequest request, HttpServletResponse response)&lt;br&gt;            throws ServletException, IOException&lt;br&gt;      {&lt;br&gt;            PrintWriter out = response.getWriter();&lt;br&gt;            String searchTerm = request.getParameter("index");&lt;br&gt;             try&lt;br&gt;            {&lt;br&gt;&lt;br&gt;                  // The application validates the user-supplied data&lt;br&gt;                  if (validateSearchTerm(searchTerm))&lt;br&gt;                  {&lt;br&gt;                        String retString;&lt;br&gt;                        retString = "The queried index \"";&lt;br&gt;                        retString += encodeHtml(searchTerm);&lt;br&gt;                        retString += "\" produced the following results:&amp;lt;br&amp;gt; ";&lt;br&gt;                        out.println(retString);&lt;br&gt;                        common.aggregateData(out, searchTerm);&lt;br&gt;                  }&lt;br&gt;                  else&lt;br&gt;                  {&lt;br&gt;                        // Add the appropriate logging and exception handling&lt;br&gt;                        // mechanisms. Consult the Exception Handling and&lt;br&gt;                        // Logging sections&lt;br&gt;                        out.println("We cannot handle your request at the moment."&lt;br&gt;                                  + "Please try again later.");&lt;br&gt;                  }&lt;br&gt;            }&lt;br&gt;             catch (Exception e)&lt;br&gt;            {&lt;br&gt;                   // Add the appropriate logging and exception handling&lt;br&gt;                   // mechanisms. Consult the Exception Handling and&lt;br&gt;                   // Logging sections&lt;br&gt;                   out.println("We cannot handle your request at the moment."&lt;br&gt;                           + " Please try again later.");&lt;br&gt;            }             out.flush();&lt;br&gt;            out.close();&lt;br&gt;      }&lt;br&gt;         boolean validateSearchTerm(String input)&lt;br&gt;      {&lt;br&gt;            String goodPattern = "(\\w|\\d)+";&lt;br&gt;            int goodLength = 8;&lt;br&gt;             if (input == null)&lt;br&gt;            {&lt;br&gt;                  return false;&lt;br&gt;            }&lt;br&gt;             if(input.length() &amp;gt; goodLength)&lt;br&gt;            {&lt;br&gt;                  return false;&lt;br&gt;            }&lt;br&gt;                        Pattern p = Pattern.compile(goodPattern);&lt;br&gt;            Matcher m = p.matcher(input);&lt;br&gt;                        if(!m.matches())&lt;br&gt;            {&lt;br&gt;                  return false;&lt;br&gt;            }&lt;br&gt;                        return true;&lt;br&gt;      }&lt;br&gt;}&lt;/pre&gt;&lt;/blockquote&gt;&lt;h1&gt;Additional Resources&lt;/h1&gt;&lt;ul&gt;&lt;li&gt;A tutorial on regular expressions is available at &lt;a href="http://www.regular-expressions.info/"&gt;Regular-Expressions.info&lt;/a&gt;. &lt;/li&gt;&lt;li&gt;For more information on using regular expression in Java, see: Documentation for &lt;a href="http://download.oracle.com/javase/1.4.2/docs/api/java/util/regex/Pattern.html"&gt;Class Pattern&lt;/a&gt; in Java SDK. &lt;/li&gt;&lt;/ul&gt;&lt;h1&gt;Related Items&lt;/h1&gt;&lt;ul&gt;&lt;li&gt;&lt;a href="ruledisplay:71225A92-ECA2-481E-ADEE-EA9C222DEA43"&gt;Guideline: Validate Input from All Sources (Java Web Application)&lt;/a&gt; &lt;/li&gt;&lt;li&gt;&lt;a href="ruledisplay:BEC58471-A0EF-40C5-8C9D-9BF5C4B91F1F"&gt;Guideline: Filter All User-Supplied Filename and Path Input (Java Web Application)&lt;/a&gt; &lt;/li&gt;&lt;li&gt;&lt;a href="ruledisplay:2D8158D1-E2D1-459F-9BD7-56D4B979EFE3"&gt;Guideline: Encode All Output Data (Java Web Application)&lt;/a&gt; &lt;/li&gt;&lt;li&gt;&lt;a href="ruledisplay:D6593992-DC9E-42C5-9E98-30E8EF075B93"&gt;Guideline: Do Not Rely on Client-Side Validation (Java Web Application)&lt;/a&gt; &lt;/li&gt;&lt;li&gt;&lt;a href="ruledisplay:044B9F0A-6A95-442C-BF24-3F890D0B10EF"&gt;Attack: Client-side Validation Attack&lt;/a&gt; &lt;/li&gt;&lt;li&gt;&lt;a href="ruledisplay:092BC54D-5A7F-451F-9EB1-AB0A1F1708C0"&gt;Attack: LDAP Injection Attack&lt;/a&gt; &lt;/li&gt;&lt;li&gt;&lt;a href="ruledisplay:BC10DCE2-CA48-44BF-8BF6-FEFBE8DCCB7E"&gt;Attack: Cross Site Scripting Attack&lt;/a&gt; &lt;/li&gt;&lt;li&gt;&lt;a href="ruledisplay:198CBDAF-3F87-4291-870D-8B6F077D8D36"&gt;Attack: AJAX Injection Attack&lt;/a&gt; &lt;/li&gt;&lt;li&gt;&lt;a href="ruledisplay:685CA8C0-E102-4517-A539-4B826D1962EB"&gt;Attack: Double Encoding Attack&lt;/a&gt; &lt;/li&gt;&lt;li&gt;&lt;a href="ruledisplay:1CCC080F-9290-4BD2-8A2C-6A45F59727B0"&gt;Attack: Xpath-XQuery Attack&lt;/a&gt; &lt;/li&gt;&lt;li&gt;&lt;a href="ruledisplay:B86F003F-DB0C-41D4-B31A-F9AE1BF7C9C1"&gt;Attack: Deserialization of Untrusted Data Attack&lt;/a&gt; &lt;/li&gt;&lt;li&gt;&lt;a href="ruledisplay:1D4FA7AF-33F0-40D9-9665-A31DBF3D7764"&gt;Attack: SQL Injection Attack&lt;/a&gt; &lt;/li&gt;&lt;li&gt;&lt;a href="ruledisplay:B9DD25F1-3C5C-40DD-A82E-464D0C02C14D"&gt;Attack: Command Injection Attack&lt;/a&gt; &lt;/li&gt;&lt;li&gt;&lt;a href="ruledisplay:208A476B-ABCA-4630-9D02-746C52F47017"&gt;Attack: XML Injection Attack&lt;/a&gt; &lt;/li&gt;&lt;li&gt;&lt;a href="ruledisplay:6D944640-22E7-421F-8192-45730D5118AB"&gt;Checklist Item: Input is Validated for Length, Range, Format and Type (Java Web Application)&lt;/a&gt; &lt;/li&gt;&lt;/ul&gt;</content>
</guidanceItem>