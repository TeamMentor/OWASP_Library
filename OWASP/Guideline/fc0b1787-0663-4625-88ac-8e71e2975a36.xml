<?xml version="1.0" encoding="utf-8"?>
<guidanceItem id="fc0b1787-0663-4625-88ac-8e71e2975a36" Author="" Category="Input and Data Validation" Priority="J.D. Meier, Alex Mackman, Michael Dunner, Srinath Vasireddy, Ray Escamilla and Anandha Murukan" Rule_Type="Guideline" Status="" Technology=" Any" title="Constrain, Reject, and Sanitize Input" Topic="Security" phase="Design" xmlns="urn:microsoft:guidanceexplorer:guidanceItem">
  <content>&lt;h1&gt;Applies to&lt;/h1&gt;&lt;ul&gt;&lt;li&gt;&lt;div&gt;Web Application&lt;/div&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1&gt;What to Do&lt;/h1&gt;&lt;p&gt;Check for known good data by validating for type, length, format, and range. Reject known bad input and then sanitize the input.&lt;/p&gt;&lt;h1&gt;Why&lt;/h1&gt;&lt;p&gt;There are no assumptions of trust that can be made regarding the safety of unchecked input. Most application-level attacks involve malicious input. Failure to validate input means that data could contain database injection attacks.&lt;/p&gt;&lt;h1&gt;When&lt;/h1&gt;&lt;p&gt;All applications should constrain and sanitize their input.&lt;/p&gt;&lt;h1&gt;How&lt;/h1&gt;&lt;p&gt;The preferred approach to validating input is to constrain what you allow from the beginning. It is much easier to validate data for known valid types, patterns, and ranges than it is to validate data by looking for known bad characters. When you design your application, you know what your application expects. The range of valid data is generally a more finite set than potentially malicious input. However, for defense in depth you may also want to reject known bad input and then sanitize the input. The recommended strategy is shown in Figure 4.4.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;Input validation strategy: constrain, reject, and sanitize input&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;To create an effective input validation strategy, be aware of the following approaches and their tradeoffs: &lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Constrain input&lt;/strong&gt;. &lt;/li&gt;&lt;li&gt;&lt;strong&gt;Validate data for type, length, format, and range&lt;/strong&gt;. &lt;/li&gt;&lt;li&gt;&lt;strong&gt;Reject known bad input&lt;/strong&gt;. &lt;/li&gt;&lt;li&gt;&lt;strong&gt;Sanitize input&lt;/strong&gt;. &lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;Constrain Input&lt;/h2&gt;&lt;p&gt;Constraining input is about allowing good data. This is the preferred approach. The idea here is to define a filter of acceptable input by using type, length, format, and range. Define what is acceptable input for your application fields and enforce it. Reject everything else as bad data.&lt;/p&gt;&lt;p&gt;Constraining input may involve setting character sets on the server so that you can establish the canonical form of the input in a localized way.&lt;/p&gt;&lt;h2&gt;Validate Data for Type, Length, Format, and Range&lt;/h2&gt;&lt;p&gt;Use strong type checking on input data wherever possible, for example, in the classes used to manipulate and process the input data and in data access routines. For example, use parameterized stored procedures for data access to benefit from strong type checking of input fields.&lt;/p&gt;&lt;p&gt;String fields should also be length checked and in many cases checked for appropriate format. For example, ZIP codes, personal identification numbers, and so on have well defined formats that can be validated using regular expressions. Thorough checking is not only good programming practice; it makes it more difficult for an attacker to exploit your code. The attacker may get through your type check, but the length check may make executing his favorite attack more difficult.&lt;/p&gt;&lt;h2&gt;Reject Known Bad Input&lt;/h2&gt;&lt;p&gt;Deny "bad" data; although do not rely completely on this approach. This approach is generally less effective than using the "allow" approach described earlier and it is best used in combination. To deny bad data assumes your application knows all the variations of malicious input. Remember that there are multiple ways to represent characters. This is another reason why "allow" is the preferred approach.&lt;/p&gt;&lt;p&gt;While useful for applications that are already deployed and when you cannot afford to make significant changes, the "deny" approach is not as robust as the "allow" approach because bad data, such as patterns that can be used to identify common attacks, do not remain constant. Valid data remains constant while the range of bad data may change over time.&lt;/p&gt;&lt;h2&gt;Sanitize Input&lt;/h2&gt;&lt;p&gt;Sanitizing is about making potentially malicious data safe. It can be helpful when the range of input that is allowed cannot guarantee that the input is safe. This includes anything from stripping a null from the end of a user-supplied string to escaping out values so they are treated as literals.&lt;/p&gt;&lt;p&gt;Another common example of sanitizing input in Web applications is using URL encoding or HTML encoding to wrap data and treat it as literal text rather than executable script. &lt;strong&gt;HtmlEncode&lt;/strong&gt; methods escape out HTML characters, and &lt;strong&gt;UrlEncode&lt;/strong&gt; methods encode a URL so that it is a valid URI request.&lt;/p&gt;&lt;h3&gt;In Practice&lt;/h3&gt;&lt;p&gt;The following are examples applied to common input fields, using the preceding approaches: &lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Last&lt;/strong&gt; &lt;strong&gt;Name field&lt;/strong&gt;. This is a good example where constraining input is appropriate In this case, you might allow string data in the range ASCII A-Z and a-z, and also hyphens and curly apostrophes (curly apostrophes have no significance to SQL) to handle names such as O'Dell. You would also limit the length to your longest expected value. &lt;/li&gt;&lt;li&gt;&lt;strong&gt;Quantity field&lt;/strong&gt;. This is another case where constraining input works well. In this example, you might use a simple type and range restriction. For example, the input data may need to be a positive integer between 0 and 1000. &lt;/li&gt;&lt;li&gt;&lt;strong&gt;Free-text field&lt;/strong&gt;. Examples include comment fields on discussion boards. In this case, you might allow letters and spaces, and also common characters such as apostrophes, commas, and hyphens. The set that is allowed does not include less than and greater than signs, brackets, and braces. &lt;p&gt;Some applications might allow users to mark up their text using a finite set of script characters, such as bold "&amp;lt;b&amp;gt;", italic "&amp;lt;i&amp;gt;", or even include a link to their favorite URL. In the case of a URL, your validation should encode the value so that it is treated as a URL. &lt;/p&gt;&lt;p&gt;For more information about validating free text fields, see "Input Validation" in Chapter 10, "&lt;a href="http://msdn.microsoft.com/library/en-us/dnnetsec/html/THCMCh10.asp"&gt;Building Secure ASP.NET Pages and Controls&lt;/a&gt;." &lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;An existing Web application that does not validate user input&lt;/strong&gt;. In an ideal scenario, the application checks for acceptable input for each field or entry point. However, if you have an existing Web application that does not validate user input, you need a stopgap approach to mitigate risk until you can improve your application's input validation strategy. While neither of the following approaches ensures safe handling of input, because that is dependent on where the input comes from and how it is used in your application, they are in practice today as quick fixes for short-term security improvement: &lt;ul&gt;&lt;li&gt;&lt;strong&gt;HTML-encoding and URL-encoding user input when writing back to the client&lt;/strong&gt;. In this case, the assumption is that no input is treated as HTML and all output is written back in a protected form. This is sanitization in action. &lt;/li&gt;&lt;li&gt;&lt;strong&gt;Rejecting malicious script characters&lt;/strong&gt;. This is a case of rejecting known bad input. In this case, a configurable set of malicious characters is used to reject the input. As described earlier, the problem with this approach is that bad data is a matter of context. &lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;For more information and examples of input coding, using regular expressions, and ASP.NET validation controls, see "Input Validation" in Chapter 10, "Building Secure ASP.NET Pages and Controls." at &lt;a href="http://msdn2.microsoft.com/en-us/library/aa302426.aspx"&gt;http://msdn2.microsoft.com/en-us/library/aa302426.aspx&lt;/a&gt;&amp;nbsp;&lt;/p&gt;&lt;h1&gt;Additional Resources&lt;/h1&gt;&lt;ul&gt;&lt;li&gt;For more information see, "Chapter 4 - Design Guidelines for Secure Web Applications" at &lt;a href="http://msdn2.microsoft.com/en-us/library/aa302420.aspx"&gt;http://msdn2.microsoft.com/en-us/library/aa302420.aspx&lt;/a&gt;&amp;nbsp;&amp;nbsp; &lt;/li&gt;&lt;/ul&gt;&lt;hr&gt;&lt;p&gt;Adapted from Microsoft patterns &amp;amp; practices guidance.&lt;/p&gt;</content>
</guidanceItem>